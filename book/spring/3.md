# 3. 템플릿

## 예외처리 기능을 갖춘 DAO

```java
// 예외 처리 기능이 없다!
public void deleteAll() throws SQLException {
    Connection c = dataSource.getConnection();
    
    // 아래에서 예외 발생시 close 되지 않고 리소를 반환을 하지 못한다.
    PreparedStatement ps = c.prepareStatement("delete from users");
    ps.executeUpdate();
    
    ps.close();
    c.close();
}
```

```java
// 예외 처리 완료! 하지만...
public void deleteAll() throws SQLException {
    Connection c = null;
    PreparedStatement ps = null;
    
    try {
        c = dataSource.getConnection();
        ps = c.prepareStatement("delete from users");
        ps.executeUpdate();
    } catch (SQLException e) {
        throw e;
    } finally {
        if (ps != null) {
            try {
                ps.close();
            } catch (SQLException e) {}
        }
        if (c != null) {
            try {
                c.close();
            } catch (SQLException e) {}
        }
    }
}
```

## JDBC try/catch/finally의 문제점

예외처리 코드가 중첩되고, 메소드마다 반복되고 있다. 이러한 코드가 많은 부분에 있으면 실수가 발생할 확률이 높아지며, 당장에는 문제가 발생하지 않더라도 누군가 로직을 수정하려 한다면 언젠가 문제가 발생할 수 있다.

### 분리와 재사용을 위한 디자인 패턴 적용

비슷한 기능의 메소드에서 동일하게 나타날 수 있는 변하지 않고 고정되는 부분과, 각 메소드마다 로직에 따라 변하는 부분을 구분한다.

#### 메소드 추출

변하지 않는 부분이 변하는 부분을 감싸고 있어서 변하지 않는 부분을 추출하기가 어려워 보이기 때문에 반대로 한 코드이다.

```java
public void deleteAll() throws SQLException {
    ...
    try {
        c = dataSource.getConnection();
        // 변하는 부분을 메소드로 추출
        ps = makeStatement(c);
        ps.executeUpdate();
    } catch (SQLException e) {
    ...
}

private PreparedSatatement makeStatement((Connection c) throws SQLException {
    PreparedSatement ps;
    ps = c.prepareStatement("delete from users");
    return ps;
}
```

보통 메소드 추출 리팩토링을 적용하는 경우에는 분리시킨 메소드를 다른 곳에서 재사용할 수 있어야 하는데, 이건 반대로 분리시키고 남은 메소드가 재사용이 필요한 부분이고, 분리된 메소드는 DAO 로직마다 새롭게 만들어서 확장돼야 하는 부분이라 이득이 없어 보인다.

#### 템플릿 메소드 패턴의 적용

`템플릿 메소드 패턴은 상속을 통해 기능을 확장해서 사용`하는 부분이다. 변하지 않는 부분은 슈퍼클래스에 두고 변하는 부분은 추상 메소드로 정의해둬서 서브클래스에서 오버라이드하여 새롭게 정의해 쓰도록 하는 것이다.

```java
public class UserDaoDeleteAll extends UserDao {
    protected PreparedStatement makeStatement(Connection c) throws SQLException {
        PreparedStatement ps = c.prepareStatement("delete from users");
        return ps;
    }
}
```

UserDao 클래스의 기능을 확장하고 싶을 때마다 상속 통해 자유롭게 확장할 수 있고, 확장 때문에 상위 클래스에 불필요한 변화는 생기지 않도록 할 수 있으니 개방 패쇄 원칙을 그럭저럭 지킬 수 있을 것 같다.

하지만 템플릿 메소드 패턴으로의 접근은 제한이 많다.

가장 큰 문제는 DAO 로직마다 상속을 통해 새로운 클래스를 만들어야 한다는 점이다. 또 확장구조가 이미 클래스를 설계하는 시점에서 고정되어 버려 유연성이 떨어진다.

#### 전략 패턴의 적용

개방 패쇄 원칙을 잘 지키는 구조이면서도 템플릿 메소드 패턴보다 유연하고 확장성이 뛰어난 것이, `오브젝트를 아예 둘로 분리하고 클래스 레벨에서는 인터페이스를 통해서만 의존하도록 만드는 전략 패턴`이다.

```java
public interface StatementStrategy {
    PreparedStatement makePreparedStatement(Connection c) throws SQLEception;
}

public class DeleteAllStatement implements StatementStrategy {
    public PreparedStatement makePreparedStatement(Connection c) throws SQLException {
        PreparedStatement ps = c.prepareStatement("delete from users");
        return ps;
    }
}

public void delteAll() throws SQLException {
    ...
    try {
        c = dataSource.getConnection();
        StatementStrategy strategy = new DeleteAllStatement();
        ps = strategy.makePreparedStatement(c);
        ps.executeUpdate();
    } catch (SQLException e) {
    ...
}
```

전략 패턴은 필요에 따라 컨텍스트는 그대로 유지되면서\(ocp\) 전략을 바꿔 쓸 수 있다는 것인데, 이렇게 컨텍스트 안에서 이미 구체적인 전략 클래스인 DeleteAllStatement를 사용하도록 고정되어 있다면 이상하다. 컨텍스트가 인터페이스뿐 아니라 특정 구현 클래스를 직접 알고 있다는건 OCP에 어긋나는 것이다.

#### DI 적용을 위한 클라이언트/컨텍스트 분리

전략 패턴에 따르면 컨텍스트가 어떤 전략을 사용하게 할 것인가는 컨텍스트를 사용하는 클라이언트가 결정하는게 일반적이다. 클라이언트가 구체적인 전략의 하나를 선택하고 오브젝트로 만들어서 컨텍스트에 전달하는 것이다. 컨텍스트

