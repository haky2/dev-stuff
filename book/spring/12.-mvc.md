# 12. 스프링 MVC

## 컨트롤러

### 컨트롤러의 종류와 핸들러 어댑터

#### Servlet과 SimpleServletHandlerAdapter

서블릿을 컨트롤러로 사용했을 때의 장점은 서블릿 클래스 코드를 그대로 유지하면서 스프링 빈으로 등록된다는 점이다. 따라서 서블릿 코드를 점진적으로 스프링 애플리케이션에 맞게 포팅할 때 유용하다.

단, 서블릿이 컨트롤러 빈으로 등록된 경우 init\(\), destory\(\)와 같은 생명주기 메소드가 호출되지 않는다는 점을 주의하자. 서블릿에서 초기화 작업을 하는 코드가 있다면 @PostConstruct 애노테이션 등을 이용해 빈 생성 후에 초기화 메소드가 실행되게 해야한다.

#### HttpRequestHandler와 HttpRequestHandlerAdapter

HttpRequestHandler는 서블릿처럼 동작하는 컨트롤러를 만들기 위해 사용한다. 전형적인 서블릿 스펙을 준수할 필요 없이 HTTP 프로토콜을 기반으로 한 전용 서비스를 만들려고 할 때 사용할 수 있다.

#### Controller와 SimpleControllerHandlerAdapter

Controller 컨트롤러는 DispatcherServlet이 컨트롤러와 주고받는 정보를 그대로 메소드의 파라미터와 리턴 값으로 갖고 있다. 따라서 스프링 MVC의 가장 대표적인 컨트롤러 타입이라고 볼 수 있다. 

```java
public interface Controller {
    ModelAndView handleRequest(HttpServletRequest request,
                               HttpServeltResponse response) throws Exception;
}
```

Controller 타입의 컨트롤러는 Controller 인터페이스를 구현하기만 하면 되기 때문에, 특정 클래스를 상속하도록 강제하는 여타 MVC 프레임워크의 컨트롤러보다 유연하게 컨트롤러 클래스를 설계할 수 있다는 장점이 있다. 하지만 실제로는 이 Controller 인터페이스를 직접 구현해 컨트롤러를 만드는 것은 권장되지 않는다. 적어도 웹 브라우저를 클라이언트로 갖는 컨트롤러로서의 필수 기능이 구현되어 있는 AbstractController를 상속해서 컨트롤러를 만드는게 편리하기 때문이다. 물론 AbstractController는 Controller 인터페이스를 구현한 Controller 타입의 컨트롤러다.

#### AnnotationMethodHandlerAdapter

AnnotationMethodHandlerAdapter는 여타 핸들러 어댑터와는 다른 독특한 특징이 있. 가장 큰 특징은 지원하는 컨트롤러의 타입이 정해져 있지 않다는 점이다. 다른 핸들러 어댑터는 특정 인터페이스를 구현한 컨트롤러만을 지원한다. 반면에 AnnotationMethodHandlerAdapter는 컨트롤러 타입에는 제한이 없다. 대신 클래스와 메소드에 붙은 몇 가지 애노테이션의 정보와 메소드 이름, 파라미터, 리턴 타입에 대한 규칙 등을 종합적으로 분석해서 컨트롤러를 선별하고 호출 방식을 결정한다. 그 덕분에 상당히 유연한 방식으로 컨트롤러를 작성할 수 있다.

또 다른 특징은 컨트롤러 하나가 하나 이상의 URL에 매핑될 수 있다는 점이다. 여타 컨트롤러는 특정 인터페이스를 구현하면 그 인터페이스의 대표 메소드를 통해 컨트롤러가 호출되기 때문에, 특별한 확장 기능을 사용하는 경우를 제외하면 URL당 하나의 컨트롤러가 매핑되는 구조다. 이렇게 하면 컨트롤러는 단순해지지만 웹 요청의 개수가 늘어나면 그에 따라 컨트롤러의 숫자도 급격하게 늘어날 수 밖에 없다. AnnotationMethodHandlerAdapter를 도입하면서 URL의 매핑을 컨트롤러 단위가 아니라 메소드 단위로 가능하게 했다. 컨트롤러 클래스 하나에 여러 개의 컨트롤러 메소드를 넣을 수 있으니 당연히 하나의 컨트롤러가 여러 개의 URL을 매핑받아서 처리할 수 있다. 메소드 단위로 컨트롤러 로직을 넣으려면 유연한 방식으로 매핑정보 등을 지정해줘야 하기 때문에 애노테이션을 필요로 한다.

```java
@Controller
pulbic class HelloController {
    
    @RequestMapping("/hello")
    public STring hello(@RequestParam("name") String name, ModelMAp map) {
        map.put("message", "Hello " + name);
        return "/WEB-INF/view/hello.jsp";
    }
}
```

### 핸들러 매핑

핸들러 매핑은 HTTP 요청정보를 이용해서 이를 처리할 핸들러 오브젝트, 즉 컨트롤러를 찾아주는 기능을 가진 DispatcherServlet의 전략이다. 핸들러 매핑은 컨트롤러의 타입과는 상관없다. 하나의 핸들러 매핑 전략이 여러 가지 타입의 컨트롤러를 선택할 수 있다는 뜻이다.

#### BeanNameUrlHandlerMapping

디폴트 핸들러 매핑의 하나다. 빈의 이름에 들어 있는 URL을 HTTP 요청의 URL과 비교해서 일치하는 빈을 찾아준다. 가장 직관적이고 사용하기 쉬운 핸들러 매핑 전략이다. URL에는 ANT 패턴이라고 불리는 \*나 \*\*, ? 와 같은 와일드카드를 사용하는 패턴을 넣을 수 있다. 이때는 패턴에 일치하는 모든 URL을 가진 요청이 해당 컨트롤러 빈으로 매핑된다.

```markup
<bean name="/root/**/sub" class="springobok...Controller">
```

디폴트 전략이고 사용하기도 간편해서 빠르고 쉽게 URL 매핑정보를 지정할 수 있다. 반면에 컨트롤러의 개수가 많아지면 URL 정보가 빈 선언이나 클래스의 애노테이션 등에 분산되어 나타나므로 전체적인 매핑구조를 한눈에 파악하고 관리하기 불편하다. 따라서 복잡한 애플리케이션에서는 잘 사용하지 않는다.

#### ControllerBeanNameHandlerMapping

ControllerBeanNameHandlerMapping은 빈의 아이디나 빈 이름을 이용해 매핑해주는 핸들러 매핑 전략이다. 

```java
@Component("hello")
public class MyController implements Controller {
    ...
}
```

ControllerBeanNameHandlerMapping은 디폴트 핸들러 매핑이 아니므로 사용하려면 전략 빈으로 등록해줘야 한다. 특정 전략 클래스를 빈으로 등록한 경우에는 디폴트 전략은 모두 무시된다는 점에 주의해야 한다. 특정 전략을 빈으로 등록하면 디폴트 핸들러 매핑인 AnnotationMethodHandlerAdapter와 DefaultAnnotationHandlerMapping은 적용되지 않는다.

#### ControllerClassNameHandlerMapping

ControllerClassNameHandlerMapping은 빈 이름 대신 클래스 이름을 URL에 매핑해주는 핸들러 매핑 클래스다. 기본적으로는 클래스 이름을 모두 URL로 사용하지만 Controller로 끝날 때는 Controller를 뺀 나머지 이름을 URL에 매핑해준다.

```java
pulbic class HelloContoller implements Controller { ... }
```

#### SimpleUrlHandlerMapping

BeanNameUrlHandlerMapping은 빈 이름에 매핑정보를 넣기 때문에 매핑정보를 관리하기 불편하다는 단점이 있다. SimpleUrlHandlerMapping은 URL과 컨트롤러의 매핑정보를 한곳에 모아놓을 수 있는 핸들러 매핑 전략이다. 매핑정보는 SimpleUrlHandlerMapping 빈의 프로퍼티에 넣어준다.

SimpleUrlHandlerMapping의 장점은 매핑정보가 한곳에 모여 있기 때문에 URL을 관리하기가 편리하다는 것이다. 그래서 컨트롤러의 개수가 많은 대규모의 프로젝트에서는 선호하기도 한다. 단점은 컨트롤러 빈의 이름을 직접 적어줘야 하기 때문에 오타 등의 오류가 발생할 가능성이 있다는 것이다.

#### DefaultAnnotationHandlerMapping

@RequestMapping이라는 애노테이션을 컨트롤러 클래스나 메소드에 직접 부여하고 이를 이용해 매핑하는 전략이다. @RequestMapping은 메소드 단위로 URL을 매핑해줄 수 있어서 컨트롤러의 개수를 획기적으로 줄일 수 있다는 장점이 있다. 또한 GET/POST와 같은 HTTP 메소드, 파라미터와 HTTP 헤더정보까지 매핑에 활용할 수 있다.

### 핸들러 인터셉터

핸들러 매핑의 역할은 기본적으로 URL과 요청정보로부터 컨트롤러 빈을 찾아주는 것이다. 그런데 한 가지 중요한 기능이 더 있다. 바로 핸들러 인터셉터를 적용해주는 것이다. 핸들러 인터셉터는 DispatcherServlet이 컨트롤러를 호출하기 전과 후에 요청과 응답을 참조하거나 가공할 수 있는 일종의 필터다. 서블릿 필터와 유사한 개념이라고 보면 된다.

#### HandlerInterceptor

핸들러 인터셉터는 HandlerInterceptor 인터페이스를 구현해서 만든다. 이 인터페이스 안에는 세 개의 메소드가 포함되어 있다.

```java
boolean preHandle(HttpServletRequest request, 
    HttpServletResponse response, Object handler) throws Exception
```

preHandle\(\) 메소드는 컨트롤러가 호출되기 전에 실행된다. handler 파라미터는 핸들러 매핑이 찾아준 컨트롤러 빈 오브젝트다. 리턴 값이 false라면 작업을 중단하고 리턴하므로 컨트롤러와 남은 인터셉터들은 실행되지 않는다.

```java
void postHandle(HttpServletRequest request, 
    HttpServletResponse response, Object handler,
    ModelAndView modelAndView) throws Exception
```

postHandle\(\) 메소드는 컨트롤러를 실행하고 난 후에 호출된다.

```java
void afterCompletion(HttpServletRequest request, 
    HttpServletResponse response, Object handler,
    Exception ex) throws Exception
```

afterCompletion\(\) 메소드는 모든 뷰에서 최종 결과를 생성하는 일을 포함한 모든 작업이 다 완료된 후에 실행된다. 요청 처리 중에 사용한 리소스를 반환해주기에 적당한 메소드다.

#### 핸들러 인터셉터 적용

핸들러 인터셉터를 사용하려면 먼저 핸들러 매핑 클래스를 빈으로 등록해야 한다. 핸들러 매핑 빈의 interceptors 프로퍼티를 이용해 핸들러 인터셉터 빈의 레퍼런스를 넣어주면 된다.

핸들러 인터셉터를 사용하는 대신 컨트롤러에 AOP를 적용하는 건 어떨까?

AOP를 이용해 컨트롤러에 일괄 적용할 부가기능을 어드바이스로 만들어서 적용할 수는 있다. 하지만 컨트롤러의 호출 과정에 적용되는 부가기능은 핸들러 인터셉터를 사용하는 편이 낫다. 스프링 MVC의 컨트롤러는 타입이 하나로 정해져 있지 않고, 실행 메소드 또한 제각각이기 때문에 적용할 메소드를 선별하는 포인트컷 작성도 쉽지 않다. 게다가 파라미터나 리턴 값 또한 일정치 않다. 특히 애노테이션을 이용해 정의한 컨트롤러는 일정한 인터페이스를 구현하고 있지 않는데다, 메소드마다 파라미터와 리턴 값도 제각각이다.

반대로 스프링 MVC는 모든 종류의 컨트롤러에게 동일한 핸들러 인터셉터를 적용할 수 있게 해준다. 따라서 컨트롤러에 공통적으로 적용할 부가기능이라면 핸들러 인터셉터를 이용하는 편이 낫다.

## 뷰

뷰는 MVC 아키텍처에서 모델이 가진 정보를 어떻게 표현해야 하는지에 대한 로직을 갖고 있는 컴포넌트다. 웹 환경에서 뷰가 생성하는 결과물은 일반적으로 브라우저에 나타낼 수 있는 HTML이다.

컨트롤러가 작업을 마친 후 뷰 정보를 ModelAndView 타입 오브젝트에 담아서 DispatcherServlet에 돌려주는 방법은 두 가지가 있다. 첫째는 View 타입의 오브젝트를 돌려주는 방법이고, 두 번째는 뷰 이름을 돌려주는 방법이다. 뷰 이름을 돌려주는 경우는 뷰 이름으로부터 실제 사용할 뷰를 결정해주는 뷰 리졸버가 필요하다.

### 뷰

스프링에서 제공하는 주요 

