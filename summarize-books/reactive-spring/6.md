---
description: 비동기 논블로킹 통신
---

# 06. 웹플럭스

## 리액티브 기반 서버 기술의 핵심: 웹플럭스

스프링 프레임워크 팀이 당면한 핵심 과제는 동일한 애노테이션 기반 프로그래밍 모델을 지원하면서 비동기 논블로킹 서버의 모든 이점을 동시에 제공하는 새로운 솔루션을 구축하는 것이었다.

### 웹플럭스로 구현하는 순수한 함수형 웹

웹플럭스는 함수적인 라우팅 매핑과 복잡한 요청 라우팅 로직을 작성할 수 있는 내장 API를 제공한다.

```java
// 함수적 방법을 이용한 라우터 선언
...
import static org.springframework.web.reactive.function.server.RequestPredicates.GET;
import static org.springframework.web.reactive.function.server.RequestPredicates.POST;
...
import static org.springframework.web.reactive.function.server.RouterFunctions.nest;
import static org.springframework.web.reactive.function.server.RouterFunctions.route;

@SpringBootApplication
public class DemoApplication {

	final ServerRedirectHandler serverRedirectHandler = new ServerRedirectHandler();

	public static void main(String[] args) {
		Hooks.onOperatorDebug();
		SpringApplication.run(DemoApplication.class, args);
	}

	@Bean
	public RouterFunction<ServerResponse> routes(OrderHandler orderHandler) {
		return
			nest(path("/orders"),
				nest(accept(APPLICATION_JSON),
					route(GET("/{id}"), orderHandler::get)
					.andRoute(method(HttpMethod.GET), orderHandler::list)
				)
				.andNest(contentType(APPLICATION_JSON),
					route(POST("/"), orderHandler::create)
				)
				.andNest((serverRequest) -> serverRequest.cookies()
				                                         .containsKey("Redirect-Traffic"),
					route(all(), serverRedirectHandler)
				)
			);
	}
}
```

```java
// 요청 및 응답을 처리하는 핸들러
public class OrderHandler {

    final OrderRepository orderRepository;
    ...
    public Mono<ServerResponse> create(ServerRequest request) {
        return request
            .bodyToMono(Order.class)
            .flatMap(orderRepository::save)
            .flatMap(o ->
                ServerResponse.created(URI.create("/orders/" + o.getId()))
                              .build()
            );
    }
   ...
}
```

함수형 라우트 선언으로 변경한 라우팅 선언 기법은 모든 라우팅 구성을 한 곳에서 유지 관리하고 입력 요청을 리액티브 방식으로 처리한다. 이와 동시에 들어오는 요청 매개변수, 경로 변수 및 요청의 구성 요소에 액세스하는 측면에서 일반적인 애노테이션 기반 접근 방식과 거의 동일한 유연성을 제공한다.

### WebClient: 논블로킹을 지원하는 통신 클라이언트

본질적으로 WebClient는 이전 RestTemplate의 대체품이다. 그러나 WebClient에는 리액티브 방식에 더 잘 맞는 함수형 API가 있으며, Flux 또는 Mono와 같은 리액터 프로젝트 타입에 대한 매핑이 내장되어있다.

```java
WebClient.create("http://localhost:8080/api")
                 .get()
                 .uri("/users/{id}", 10)
                 .retrieve()
                 .bodyToMono(User.class)
                 .map(User::getUsername);
```

참고 - [Spring WebClient 사용법](https://medium.com/@odysseymoon/spring-webclient-%EC%82%AC%EC%9A%A9%EB%B2%95-5f92d295edc0)

{% hint style="info" %}
WebClient는 리액티브 스트림 스펙을 따릅니다. 즉, subscribe 메서드를 호출해 WebClient가 커넥션을 연결하고 데이터를 원격 서버로 보내기 시작합니다.
{% endhint %}

### 리액티브 템플릿 엔진

기본적으로 웹플럭스는 프리마커 렌더링 엔진만 지원한다.

### 리액티브 웹 보안

#### SecurityContext를 리액티브 방식으로 사용하기

새로운 리액티브 스프링 보안 모듈에서 SecurityContext에 액세스하기 위해 ReactiveSecurityContextHolder라는 새로운 클래스를 사용한다. 새로운 리액티브 컨텍스트 API는 기존의 동기적 구현과 상당히 유사하다.

```java
@GetMapping("/profiles")
public Mono<Profile> getProfile() {
    return ReactiveSecurityContextHolder
        .getContext()
        .map(SecurityContext::getAuthentication)
        .flatMap(auth -> profileService.getByUser(auth.getName()));
}
```

SecurityContext 전송 메커니즘은 스레드 인스턴스 간 일반적으로 발생하는 ThreadLocal 전파에 대한 문제를 신경 쓰지 않고도 복잡한 스트리밍 프로세스를 쉽게 작성할 수 있게 해준다.

## 웹플럭스 vs 웹 MVC



